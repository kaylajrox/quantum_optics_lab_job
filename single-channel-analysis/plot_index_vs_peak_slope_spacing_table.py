import matplotlib
matplotlib.use('TkAgg')

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime
from pathlib import Path
import csv

def analyze_and_save_slopes(df, results_dir, script_name):
    summary_csv = results_dir / 'results_spacing_from_slope.csv'
    detailed_csv = results_dir / 'results_detailed_peak_data.csv'

    with open(summary_csv, mode='w', newline='') as f_summary, open(detailed_csv, mode='w', newline='') as f_detailed:
        summary_writer = csv.writer(f_summary)
        detailed_writer = csv.writer(f_detailed)

        summary_writer.writerow([
            'Timestamp', 'Channel', 'Pulse Height (V)', 'Gain Voltage (V)',
            'State', 'Num Slopes Calculated', 'Average Spacing', 'Standard Deviation',
            'Fitted Slope', 'Source Files', 'Generated By'
        ])
        detailed_writer.writerow([
            'Timestamp', 'Channel', 'Pulse Height (V)', 'Gain Voltage (V)',
            'Peak Number', 'Peak Index', 'Peak Counts',
            'State', 'Num Slopes Calculated', 'Average Spacing', 'Standard Deviation',
            'Fitted Slope', 'Source File', 'Generated By'
        ])

        for ch in df['Channel'].unique():
            df_ch = df[df['Channel'] == ch]
            gain_voltages = sorted(df_ch['Voltage Gain (V)'].unique())

            for gain in gain_voltages:
                df_gain = df_ch[df_ch['Voltage Gain (V)'] == gain]
                for pulse_height in sorted(df_gain['Pulse Voltage (V)'].unique()):
                    df_pulse = df_gain[df_gain['Pulse Voltage (V)'] == pulse_height]
                    df_pulse = df_pulse.sort_values('Peak Number')

                    if len(df_pulse) < 2:
                        continue

                    state = df_pulse['State'].iloc[0] if 'State' in df_pulse.columns else 'unknown'
                    unique_sources = df_pulse['Source File'].dropna().astype(str).unique() if 'Source File' in df_pulse.columns else ['unknown']
                    source_files_str = "; ".join(unique_sources)

                    x = df_pulse['Peak Number'].values
                    y = df_pulse['Peak Index'].values
                    counts = df_pulse['Peak Counts'].values

                    slopes = np.diff(y) / np.diff(x)
                    num_slopes = len(slopes)
                    avg_slope = np.mean(slopes)
                    slope_std = np.std(slopes)

                    coeffs = np.polyfit(x, y, deg=1)
                    fitted_slope = coeffs[0]

                    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

                    # Summary
                    summary_writer.writerow([
                        timestamp, ch, pulse_height, gain,
                        state, num_slopes, avg_slope, slope_std,
                        fitted_slope, source_files_str, script_name
                    ])

                    # Detailed
                    for i in range(len(df_pulse)):
                        detailed_writer.writerow([
                            timestamp, ch, pulse_height, gain,
                            x[i], y[i], counts[i],
                            state, num_slopes, avg_slope, slope_std,
                            fitted_slope, source_files_str, script_name
                        ])

    print(f"✅ Final slope analysis written to: {summary_csv}, {detailed_csv}")

# === Main Execution ===
script_dir = Path(__file__).resolve().parent
repo_root = script_dir.parent
results_dir = repo_root / "results-from-generated-data"
results_dir.mkdir(parents=True, exist_ok=True)

data_file = results_dir / "all_peaks_combined_sorted.csv"
print(f"Loading data from: {data_file}")

df = pd.read_csv(data_file)
df.columns = df.columns.str.strip()

# Run slope analysis function
analyze_and_save_slopes(df, results_dir, Path(__file__).name)

# === Plotting Section ===
pulse_color_map = {1.0: 'black', 1.1: 'darkblue', 1.3: 'green', 1.6: 'orange', 2.0: 'deeppink', 2.3: 'red'}

for ch in df['Channel'].unique():
    df_ch = df[df['Channel'] == ch]
    gain_voltages = sorted(df_ch['Voltage Gain (V)'].unique())

    for gain in gain_voltages:
        plt.figure(figsize=(10, 6))
        df_gain = df_ch[df_ch['Voltage Gain (V)'] == gain]

        for pulse_height in sorted(df_gain['Pulse Voltage (V)'].unique()):
            df_pulse = df_gain[df_gain['Pulse Voltage (V)'] == pulse_height]
            df_pulse = df_pulse.sort_values('Peak Number')

            x = df_pulse['Peak Number'].values
            y = df_pulse['Peak Index'].values
            color = pulse_color_map.get(pulse_height, 'gray')

            if len(x) >= 2:
                coeffs = np.polyfit(x, y, deg=1)
                x_fit = np.linspace(min(x), max(x), 300)
                y_fit = np.polyval(coeffs, x_fit)

                plt.plot(x_fit, y_fit, linestyle='--', color=color, label=f'{pulse_height}V fit')
                eqn_str = f'y = {coeffs[0]:.2f}x + {coeffs[1]:.1f}'
                plt.text(x_fit[-1]+0.3, y_fit[-1], eqn_str, fontsize=10, color=color, va='center')

            plt.plot(x, y, marker='o', linestyle='-', color=color, label=f'{pulse_height}V pulse')

        plt.title(f'{ch} — Peak Index vs. Peak Number (Gain = {gain} V)')
        plt.xlabel('Peak Number')
        plt.ylabel('Peak Index')
        plt.grid(True)
        plt.legend(title='Pulse Height')
        plt.tight_layout()
        plt.show()

# import matplotlib
# matplotlib.use('TkAgg')  # For PyCharm interactivity
#
# import pandas as pd
# import matplotlib.pyplot as plt
# import numpy as np
# from datetime import datetime
# from pathlib import Path
# import csv
#
# # === Path Setup ===
# script_dir = Path(__file__).resolve().parent
# repo_root = script_dir.parent
# results_dir = repo_root / "results-from-generated-data"
# results_dir.mkdir(parents=True, exist_ok=True)
#
# # === File Paths ===
# data_file = results_dir / "all_peaks_combined_sorted.csv"
# output_csv = results_dir / "results_spacing_from_slope.csv"
#
# # === Load Data ===
# print(f"Loading data from: {data_file}")
# df = pd.read_csv(data_file)
# df.columns = df.columns.str.strip()  # Remove extra spaces from headers
#
# print("\n✅ Columns in Data File:")
# print(df.columns.tolist())
#
# # === Column Name Aliasing ===
# # Try common possible column names to avoid KeyErrors
# channel_col = next((col for col in df.columns if 'channel' in col.lower()), None)
# gain_col = next((col for col in df.columns if 'gain' in col.lower()), None)
# pulse_col = next((col for col in df.columns if 'pulse' in col.lower()), None)
#
# if not all([channel_col, gain_col, pulse_col]):
#     raise KeyError(f"Could not find required columns: Channel={channel_col}, Gain={gain_col}, Pulse={pulse_col}")
#
# # === Prepare CSV Output ===
# with open(output_csv, mode='w', newline='') as file:
#     writer = csv.writer(file)
#     writer.writerow([
#         'Current time of data made', 'Channel', 'Pulse Height (V)',
#         'Gain Voltage (V)', 'Average Spacing', 'Standard Deviation'
#     ])
#
#     pulse_color_map = {
#         1.0: 'black', 1.1: 'darkblue', 1.3: 'green',
#         1.6: 'orange', 2.0: 'deeppink', 2.3: 'red'
#     }
#
#     # === Main Loop ===
#     for ch in df[channel_col].unique():
#         df_ch = df[df[channel_col] == ch]
#         gain_voltages = sorted(df_ch[gain_col].unique())
#
#         for gain in gain_voltages:
#             plt.figure(figsize=(8, 6))
#             df_gain = df_ch[df_ch[gain_col] == gain]
#
#             print(f"\n=== CHANNEL: {ch} | GAIN VOLTAGE: {gain} V ===")
#
#             for pulse_height in sorted(df_gain[pulse_col].unique()):
#                 df_pulse = df_gain[df_gain[pulse_col] == pulse_height]
#                 df_pulse = df_pulse.sort_values('Peak Number')
#
#                 x = df_pulse['Peak Number'].values
#                 y = df_pulse['Peak Index'].values
#                 color = pulse_color_map.get(pulse_height, 'gray')
#
#                 print(f"\n→ Pulse Height = {pulse_height} V")
#
#                 if len(x) >= 2:
#                     slopes = np.diff(y) / np.diff(x)
#                     avg_slope = np.mean(slopes)
#                     slope_std = np.std(slopes)
#                     timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
#
#                     for i, s in enumerate(slopes, start=1):
#                         print(f"   Slope between Peak {i} & {i+1}: {s:.2f}")
#                     print(f"   ↪ Average Slope: {avg_slope:.2f}")
#                     print(f"   ↪ Std Dev of Slopes: {slope_std:.2f}")
#
#                     # Write result to CSV
#                     writer.writerow([timestamp, ch, pulse_height, gain, avg_slope, slope_std])
#
#                     # Fit overlay
#                     coeffs = np.polyfit(x, y, deg=1)
#                     x_fit = np.linspace(min(x), max(x), 300)
#                     y_fit = np.polyval(coeffs, x_fit)
#                     plt.plot(x_fit, y_fit, linestyle='--', color=color, label=f'{pulse_height}V fit')
#
#                     # Annotate equation
#                     eqn_str = f'y = {coeffs[0]:.2f}x + {coeffs[1]:.1f}'
#                     plt.text(x_fit[-1]+0.3, y_fit[-1], eqn_str, fontsize=12, color=color, va='center')
#                 else:
#                     print("   ⚠ Not enough data points to compute slope or fit.")
#
#                 # Plot data points
#                 plt.plot(x, y, marker='o', linestyle='-', color=color, label=f'{pulse_height}V pulse')
#
#             plt.title(f'{ch} — Peak Index vs. Peak Number (Gain = {gain} V)')
#             plt.xlabel('Peak Number')
#             plt.ylabel('Peak Index')
#             plt.grid(True)
#             plt.legend(title='Pulse Height')
#             plt.tight_layout()
#             plt.show()
#
# print(f"\n✅ Slope results saved to: {output_csv}")
#
#
#
# # import matplotlib
# # matplotlib.use('TkAgg')  # For PyCharm interactivity
# #
# # import pandas as pd
# # import matplotlib.pyplot as plt
# # import numpy as np
# # from datetime import datetime
# # import csv
# # from pathlib import Path
# #
# # # === Path Setup ===
# # script_dir = Path(__file__).resolve().parent
# # repo_root = script_dir.parent  # One level up from this script directory
# # results_dir = repo_root / "results-from-generated-data"
# # results_dir.mkdir(parents=True, exist_ok=True)
# #
# # # === File Paths ===
# # data_file = results_dir / "all_peaks_combined_sorted.csv"
# # output_csv = results_dir / "results_spacing_from_slope.csv"
# #
# # # === Load Data ===
# # print(f"Loading data from: {data_file}")
# # df = pd.read_csv(data_file)
# # df.columns = df.columns.str.strip()  # Remove whitespace in headers
# #
# # df['Peak Number'] = pd.to_numeric(df['Peak Number'], errors='coerce')
# # df['Peak Index'] = pd.to_numeric(df['Peak Index'], errors='coerce')
# # df = df.dropna(subset=['Peak Number', 'Peak Index'])
# #
# # # === CSV Output Setup ===
# # with open(output_csv, mode='w', newline='') as file:
# #     writer = csv.writer(file)
# #     writer.writerow([
# #         'Current time of data made', 'Channel', 'Pulse Height (V)',
# #         'Gain Voltage (V)', 'Average Spacing', 'Standard Deviation'
# #     ])
# #
# #     pulse_color_map = {
# #         1.0: 'black', 1.1: 'darkblue', 1.3: 'green',
# #         1.6: 'orange', 2.0: 'deeppink', 2.3: 'red'
# #     }
# #
# #     # === Loop over Channels & Gains ===
# #     for ch in df['Channel (from filename)'].unique():
# #         df_ch = df[df['Channel (from filename)'] == ch]
# #         gain_voltages = sorted(df_ch['Gain Voltage (from filename)'].unique())
# #
# #         for gain in gain_voltages:
# #             plt.figure(figsize=(8, 6))
# #             df_gain = df_ch[df_ch['Gain Voltage (from filename)'] == gain]
# #
# #             print(f"\n=== CHANNEL: {ch} | GAIN VOLTAGE: {gain} V ===")
# #
# #             for pulse_height in sorted(df_gain['Pulse Height (from filename)'].unique()):
# #                 df_pulse = df_gain[df_gain['Pulse Height (from filename)'] == pulse_height]
# #                 df_pulse = df_pulse.sort_values('Peak Number')
# #
# #                 x = df_pulse['Peak Number'].values
# #                 y = df_pulse['Peak Index'].values
# #                 color = pulse_color_map.get(pulse_height, 'gray')
# #
# #                 print(f"\n→ Pulse Height = {pulse_height} V")
# #
# #                 if len(x) >= 2:
# #                     slopes = np.diff(y) / np.diff(x)
# #                     avg_slope = np.mean(slopes)
# #                     slope_std = np.std(slopes)
# #                     timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
# #
# #                     for i, s in enumerate(slopes, start=1):
# #                         print(f"   Slope between Peak {i} & {i+1}: {s:.2f}")
# #                     print(f"   ↪ Average Slope: {avg_slope:.2f}")
# #                     print(f"   ↪ Std Dev of Slopes: {slope_std:.2f}")
# #
# #                     # Save result to CSV
# #                     writer.writerow([timestamp, ch, pulse_height, gain, avg_slope, slope_std])
# #
# #                     # Linear Fit Overlay
# #                     coeffs = np.polyfit(x, y, deg=1)
# #                     x_fit = np.linspace(min(x), max(x), 300)
# #                     y_fit = np.polyval(coeffs, x_fit)
# #                     plt.plot(x_fit, y_fit, linestyle='--', color=color, label=f'{pulse_height}V fit')
# #
# #                     # Annotate Equation
# #                     eqn_str = f'y = {coeffs[0]:.2f}x + {coeffs[1]:.1f}'
# #                     plt.text(x_fit[-1]+0.3, y_fit[-1], eqn_str, fontsize=12, color=color, va='center')
# #                 else:
# #                     print("   ⚠ Not enough data points to compute slope or fit.")
# #
# #                 # Plot Actual Data Points
# #                 plt.plot(x, y, marker='o', linestyle='-', color=color, label=f'{pulse_height}V pulse')
# #
# #             plt.title(f'{ch} — Peak Index vs. Peak Number (Gain = {gain} V)')
# #             plt.xlabel('Peak Number')
# #             plt.ylabel('Peak Index')
# #             plt.grid(True)
# #             plt.legend(title='Pulse Height')
# #             plt.tight_layout()
# #             plt.show()
# #
# # print(f"\n✅ Slope results written to: {output_csv}")
# #
# #
# #
# # # # import numpy as np
# # # # import matplotlib.pyplot as plt
# # # # from lmfit import Model, Parameters
# # # # from pathlib import Path
# # # # import os
# # # #
# # # # # --- Resolve Repo Root and Results Directory ---
# # # # script_dir = Path(__file__).resolve().parent
# # # # repo_root = script_dir.parent  # Adjust if deeper
# # # # results_dir = repo_root / "results-from-generated-data"
# # # # os.makedirs(results_dir, exist_ok=True)
# # # #
# # # # # --- Data File Paths ---
# # # # file_path_CH0 = "../data-photon-counts-SiPM/data-photon-counts-SiPM/20250428_pulse_height_vary/65_7_gain_1_0_pulse_300s/CH0@DT5720B_75_EspectrumR_65_7_gain_1_0_pulse_300s_20250428_160229.txt"
# # # # file_path_CH1 = "../data-photon-counts-SiPM/data-photon-counts-SiPM/20250428_more_light/65_7_gain_1_0_pulse_300s/CH1@DT5720B_75_EspectrumR_65_7_gain_1_0_pulse_300s_20250428_160229.txt"
# # # # print(file_path_CH0)
# # # # # --- Load Data ---
# # # # energies_CH1 = np.loadtxt(file_path_CH0)
# # # # energies_CH1_cropped = energies_CH1[:-3850]
# # # # x = np.arange(len(energies_CH1_cropped))  # X-axis (index)
# # # #
# # # # # --- Good peak indices (manual selection for now) ---
# # # # good_peak_indices = [33, 65]
# # # # mu_guesses = x[good_peak_indices]
# # # #
# # # # # --- Model Definition ---
# # # # def envelope_sum(x, mu_env, sigma_env, A_env, sigma_narrow, **kwargs):
# # # #     envelope = A_env * np.exp(- (x - mu_env)**2 / (2 * sigma_env**2))
# # # #     peak_sum = np.zeros_like(x)
# # # #     for key in kwargs:
# # # #         if key.startswith('A_'):
# # # #             i = key.split('_')[1]
# # # #             mu_i = kwargs[f'mu_{i}']
# # # #             A_i = kwargs[key]
# # # #             peak_sum += A_i * np.exp(- (x - mu_i)**2 / (2 * sigma_narrow**2))
# # # #     return envelope * peak_sum
# # # #
# # # # model = Model(envelope_sum, independent_vars=['x'])
# # # #
# # # # # --- Parameters ---
# # # # params = Parameters()
# # # # params.add('mu_env', value=np.mean(mu_guesses), min=0, max=len(x))
# # # # params.add('sigma_env', value=50, min=1, max=200)
# # # # params.add('A_env', value=1.0, min=0.1)
# # # # params.add('sigma_narrow', value=3.0, min=0.5, max=20)
# # # #
# # # # for i, mu in enumerate(mu_guesses):
# # # #     params.add(f'mu_{i}', value=mu, vary=False)
# # # #     params.add(f'A_{i}', value=1.0, min=0.0)
# # # #
# # # # # --- Fit Model ---
# # # # result = model.fit(energies_CH1_cropped, params, x=x)
# # # #
# # # # # --- Plot Result ---
# # # # plt.figure(figsize=(10, 5))
# # # # plt.plot(x, energies_CH1_cropped, 'o', markersize=3, label='Data', color='blue')
# # # # plt.plot(x, result.best_fit, 'r-.', label='Best Fit', color='red')
# # # # plt.xlabel("Index")
# # # # plt.ylabel("Counts")
# # # # plt.title("LMFit: Envelope × Sum of Gaussians")
# # # # plt.legend()
# # # # plt.grid(True)
# # # # plt.tight_layout()
# # # # plt.show()
# # # #
# # # # # --- Save Fit Report to CSV in results-from-generated-data ---
# # # # output_file = results_dir / "fit_results_peak_analysis.csv"
# # # # with open(output_file, 'w') as f:
# # # #     f.write(result.fit_report())
# # # # print(f"Fit report saved to {output_file}")
# # # #
# # #
# # #
# # #
# # # import matplotlib
# # # matplotlib.use('TkAgg')  # For PyCharm interactivity
# # #
# # # import pandas as pd
# # # import matplotlib.pyplot as plt
# # # import numpy as np
# # # from datetime import datetime
# # # import csv
# # # from pathlib import Path
# # #
# # #
# # # # Load data
# # # df = pd.read_csv('..results-from-generated-data/all_peaks_combined_sorted.csv')
# # # df.columns = df.columns.str.strip()
# # # df['Peak Number'] = pd.to_numeric(df['Peak Number'], errors='coerce')
# # # df['Peak Index'] = pd.to_numeric(df['Peak Index'], errors='coerce')
# # # df = df.dropna(subset=['Peak Number', 'Peak Index'])
# # #
# # # # Setup output file
# # # csv_filename = '..results-from-generated-data/results_spacing_from_slope.csv'
# # # with open(csv_filename, mode='w', newline='') as file:
# # #     writer = csv.writer(file)
# # #     writer.writerow([
# # #         'Current time of data made', 'Channel', 'Pulse Height (V)',
# # #         'Gain Voltage (V)', 'Average Spacing', 'Standard Deviation'
# # #     ])
# # #
# # #     pulse_color_map = {
# # #         1.0: 'black', 1.1: 'darkblue', 1.3: 'green',
# # #         1.6: 'orange', 2.0: 'deeppink', 2.3: 'red'
# # #     }
# # #
# # #     for ch in df['Channel (from filename)'].unique():
# # #         df_ch = df[df['Channel (from filename)'] == ch]
# # #         gain_voltages = sorted(df_ch['Gain Voltage (from filename)'].unique())
# # #
# # #         for gain in gain_voltages:
# # #             plt.figure(figsize=(8, 6))
# # #             df_gain = df_ch[df_ch['Gain Voltage (from filename)'] == gain]
# # #
# # #             print(f"\n=== CHANNEL: {ch} | GAIN VOLTAGE: {gain} V ===")
# # #
# # #             for pulse_height in sorted(df_gain['Pulse Height (from filename)'].unique()):
# # #                 df_pulse = df_gain[df_gain['Pulse Height (from filename)'] == pulse_height]
# # #                 df_pulse = df_pulse.sort_values('Peak Number')
# # #
# # #                 x = df_pulse['Peak Number'].values
# # #                 y = df_pulse['Peak Index'].values
# # #                 color = pulse_color_map.get(pulse_height, 'gray')
# # #
# # #                 print(f"\n→ Pulse Height = {pulse_height} V")
# # #
# # #                 if len(x) >= 2:
# # #                     slopes = np.diff(y) / np.diff(x)
# # #                     avg_slope = np.mean(slopes)
# # #                     slope_std = np.std(slopes)
# # #                     timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
# # #
# # #                     for i, s in enumerate(slopes, start=1):
# # #                         print(f"   Slope between Peak {i} & {i+1}: {s:.2f}")
# # #                     print(f"   ↪ Average Slope: {avg_slope:.2f}")
# # #                     print(f"   ↪ Std Dev of Slopes: {slope_std:.2f}")
# # #
# # #                     # Save to CSV
# # #                     writer.writerow([timestamp, ch, pulse_height, gain, avg_slope, slope_std])
# # #
# # #                     # Fit line
# # #                     coeffs = np.polyfit(x, y, deg=1)
# # #                     x_fit = np.linspace(min(x), max(x), 300)
# # #                     y_fit = np.polyval(coeffs, x_fit)
# # #                     plt.plot(x_fit, y_fit, linestyle='--', color=color, label=f'{pulse_height}V fit')
# # #
# # #                     # Annotate
# # #                     eqn_str = f'y = {coeffs[0]:.2f}x + {coeffs[1]:.1f}'
# # #                     plt.text(x_fit[-1]+0.3, y_fit[-1], eqn_str, fontsize=12, color=color, va='center')
# # #                 else:
# # #                     print("   ⚠ Not enough data points to compute slope or fit.")
# # #
# # #                 plt.plot(x, y, marker='o', linestyle='-', color=color, label=f'{pulse_height}V pulse')
# # #
# # #             plt.title(f'{ch} — Peak Index vs. Peak Number (Gain = {gain} V)')
# # #             plt.xlabel('Peak Number')
# # #             plt.ylabel('Peak Index')
# # #             plt.grid(True)
# # #             plt.legend(title='Pulse Height')
# # #             plt.tight_layout()
# # #             plt.show()
# # #
# # # print(f"\n✅ Slope results written to: {csv_filename}")
# # #
